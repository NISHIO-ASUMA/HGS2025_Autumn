//=============================================================================
//
// ブロックマネージャー処理 [blockmanager.cpp]
// Author : RIKU TANEKAWA
//
//=============================================================================

//*****************************************************************************
// インクルードファイル
//*****************************************************************************
#include "blockmanager.h"
#include "json.hpp"
#include "manager.h"

// JSONの使用
using json = nlohmann::json;

//*****************************************************************************
// 静的メンバ変数宣言
//*****************************************************************************
std::vector<CBlock*> CBlockManager::m_blocks = {};	// ブロックの情報
int CBlockManager::m_nNumAll = 0;					// ブロックの総数

//=============================================================================
// コンストラクタ
//=============================================================================
CBlockManager::CBlockManager()
{
	// 値のクリア
}
//=============================================================================
// デストラクタ
//=============================================================================
CBlockManager::~CBlockManager()
{
	// なし
}
//=============================================================================
// 生成処理
//=============================================================================
CBlock* CBlockManager::CreateBlock(const char* filepath, D3DXVECTOR3 pos)
{
	CBlock* newBlock = CBlock::Create(filepath, pos, D3DXVECTOR3(0, 0, 0), D3DXVECTOR3(1, 1, 1));

	if (newBlock)
	{
		m_blocks.push_back(newBlock);
		m_nNumAll++;			// 総数のカウントアップ
	}

	return newBlock;
}
//=============================================================================
// 初期化処理
//=============================================================================
void CBlockManager::Init(void)
{
	// 動的配列を空にする (サイズを0にする)
	m_blocks.clear();
}
//=============================================================================
// 終了処理
//=============================================================================
void CBlockManager::Uninit(void)
{
	m_nNumAll = 0;

	// 動的配列を空にする (サイズを0にする)
	m_blocks.clear();
}
//=============================================================================
// 更新処理
//=============================================================================
void CBlockManager::Update(void)
{

	//// プレイヤーの取得
	//CPlayer* pPlayer = CGame::GetPlayer();

	//// カプセルとOBBの当たり判定
	//if (CCollision::CheckCapsuleOBBCollision(pPlayer->GetCollider(), m_pCollider))
	//{

	//}

}
//=============================================================================
// 描画処理
//=============================================================================
void CBlockManager::Draw(void)
{


}
//=============================================================================
// ブロック情報の読み込み処理
//=============================================================================
void CBlockManager::LoadFromJson(const char* filename)
{
	std::ifstream file(filename);

	if (!file.is_open())
	{// 開けなかった
		MessageBox(nullptr, "ステージファイルの読み込みに失敗しました", "エラー", MB_OK | MB_ICONERROR);
		return;
	}

	json j;
	file >> j;

	// ファイルを閉じる
	file.close();

	// 既存のブロックを消す
	for (auto block : m_blocks)
	{
		if (block != nullptr)
		{
			// ブロックの終了処理
			block->Uninit();
		}
	}

	// 動的配列を空にする (サイズを0にする)
	m_blocks.clear();
	m_nNumAll = 0;// 総数をリセット
	
	// 新たに生成
	for (const auto& b : j)
	{
		std::string filepath = b["filepath"];
		D3DXVECTOR3 pos(b["pos"][0], b["pos"][1], b["pos"][2]);
		D3DXVECTOR3 degRot(b["rot"][0], b["rot"][1], b["rot"][2]);
		D3DXVECTOR3 size(b["size"][0], b["size"][1], b["size"][2]);

		D3DXVECTOR3 rot = D3DXToRadian(degRot); // 度→ラジアンに変換

		// タイプからブロック生成
		CBlock* block = CreateBlock(filepath.c_str(), pos);

		if (!block)
		{
			continue;
		}

		block->SetRot(rot);
		block->SetSize(size);
	}
}
//=============================================================================
// 全ブロックの取得
//=============================================================================
std::vector<CBlock*>& CBlockManager::GetAllBlocks(void)
{
	return m_blocks;
}